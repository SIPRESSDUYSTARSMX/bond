<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Bond-over-gRPC</title>
  <style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; background-color: #f8f8f8; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
pre, code { background-color: #f8f8f8; }
code > span.kw { color: #204a87; font-weight: bold; } /* Keyword */
code > span.dt { color: #204a87; } /* DataType */
code > span.dv { color: #0000cf; } /* DecVal */
code > span.bn { color: #0000cf; } /* BaseN */
code > span.fl { color: #0000cf; } /* Float */
code > span.ch { color: #4e9a06; } /* Char */
code > span.st { color: #4e9a06; } /* String */
code > span.co { color: #8f5902; font-style: italic; } /* Comment */
code > span.ot { color: #8f5902; } /* Other */
code > span.al { color: #ef2929; } /* Alert */
code > span.fu { color: #000000; } /* Function */
code > span.er { color: #a40000; font-weight: bold; } /* Error */
code > span.wa { color: #8f5902; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #000000; } /* Constant */
code > span.sc { color: #000000; } /* SpecialChar */
code > span.vs { color: #4e9a06; } /* VerbatimString */
code > span.ss { color: #4e9a06; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #000000; } /* Variable */
code > span.cf { color: #204a87; font-weight: bold; } /* ControlFlow */
code > span.op { color: #ce5c00; font-weight: bold; } /* Operator */
code > span.pp { color: #8f5902; font-style: italic; } /* Preprocessor */
code > span.ex { } /* Extension */
code > span.at { color: #c4a000; } /* Attribute */
code > span.do { color: #8f5902; font-weight: bold; font-style: italic; } /* Documentation */
code > span.an { color: #8f5902; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #8f5902; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #8f5902; font-weight: bold; font-style: italic; } /* Information */
  body {
      line-height: 1.5;
      font-family: Helvetica, Arial, sans-serif;
      color: #333333;
      font-size: 1em;
  }
  code {
      font-size: 1em;
      font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace, serif;
  }
  td.lineNumbers { width: 40px; }
  div#all {
    max-width: 1120px;
    background-color: #ffffff;
    margin: 0 auto;
    padding: 25px;
    overflow: auto;
  }
  code > span.kw { color: #204a87; font-weight: normal; } /* Keyword */
  code > span.co { color: #4E9A06; font-style: normal; }
  code > span.st { color: #8A0303; font-style: normal; }
  code > span.cf { color: #204a87; font-weight: normal; } /* ControlFlow */
  code > span.op { color: #000000; font-weight: normal; } /* Operator */
  code > span.pp { color: #8f5902; font-style: normal; } /* Preprocessor */
  code > span.ex { } /* Extension */
  code > span.at { color: #c4a000; } /* Attribute */
  code > span.do { color: #8f5902; font-weight: normal; font-style: normal; } /* Documentation */
  code > span.an { color: #8f5902; font-weight: normal; font-style: normal; } /* Annotation */
  code > span.cv { color: #8f5902; font-weight: normal; font-style: normal; } /* CommentVar */
  code > span.in { color: #8f5902; font-weight: normal; font-style: normal; } /* Information */

  h1, h2, h3, h4, h5, h6 {
    font-weight: normal;
    border-bottom: 1px solid black;
  }

  div.sourceCode {
    overflow-x: auto;
    max-height: 620px;
  }

  table.sourceCode {
    line-height: 120%;
  }

  #toc {
    width: 300px;
    position:fixed;
    overflow: auto;
    height: 95%;
  }

  #main {
    margin-left: 320px;
    margin-rigth: auto;
    max-width: 800px;
  }
  a {
    text-decoration: none;
  }
  #toc a:visited {
    color: #99c;
  }
  #main a:visited {
    color: #36c;
  }
  a:link {
    color: #36c;
  }
  @media screen and (max-width: 979px){
  #main {
    margin-left: auto;
    margin-right: auto;
  }
  #toc {
    left: -300px;
  }
  }
  </style>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-58775439-1', 'auto');
  ga('send', 'pageview');

</script>
</head>
<body>
<nav id="TOC"></nav>
<div id="all">
<div id="toc">
<p><img src="data:image/png;base64,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" alt="The Bond logo: a stylized glue gun" /></p>
<ul>
<li><a href="#about">About</a></li>
<li><a href="#features">Features</a><ul>
<li><a href="#defining-services">Defining Services</a></li>
</ul></li>
<li><a href="#implementations">Implementations</a><ul>
<li><a href="#bond-over-grpc-for-c">Bond-over-gRPC for C#</a></li>
<li><a href="#bond-over-grpc-for-c-1">Bond-over-gRPC for C++</a></li>
</ul></li>
</ul>
</div>
<div id="main">
<div id="header">
<h1 class="title">Bond-over-gRPC</h1>
</div>
<h1 id="about">About</h1>
<p>Bond-over-gRPC provides code generation from Bond IDL service definitions to send Bond objects via <a href="http://www.grpc.io/">gRPC</a>.</p>
<p><strong>Bond-over-gRPC is deprecated and will be completely removed from Bond in May 2022.</strong> See GitHub issue <a href="https://github.com/microsoft/bond/issues/1131">#1131, Bond-over-gRPC will be deprecated February 2022</a>, for full details.</p>
<p>If you are looking for something similar in spirit to Bond-over-gRPC, we recommend the following.</p>
<ul>
<li>For C++, gRPC++ now supports a <a href="https://github.com/grpc/proposal/pull/180">callback-based asynchronous API</a> like Bond-over-gRPCâ€™s. Check out the <a href="https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/greeter_callback_client.cc">client</a> and <a href="https://github.com/grpc/grpc/blob/master/examples/cpp/helloworld/greeter_callback_server.cc">server</a> examples.</li>
<li>For C# and .NET, we recommend <a href="https://github.com/grpc/grpc-dotnet/">gRPC for .NET</a>. The Grpc.Core library that Bond-over-gRPC is built atop <a href="https://grpc.io/blog/grpc-csharp-future/">will no longer be supported as of May 2022</a>.</li>
<li>Both gRPC++ and gRPC for .NET support pluggable serialization formats, so you can use them with Bond, JSON, Protocol Buffers, or anything else.</li>
</ul>
<h1 id="features">Features</h1>
<h2 id="defining-services">Defining Services</h2>
<p>The Bond IDL has been extended to support the definition of <a href="compiler.html#service-definition">services</a> and <a href="compiler.html#generic-service">generic services</a>. These definitions are used by the Bond compiler to generate classes that provide:</p>
<ul>
<li>a service base that can be used as the basis for implementing servicesâ€™ methods</li>
<li>a proxy stub that can be used by clients to invoke those methods</li>
</ul>
<p>To generate these classes, pass the <code>--grpc</code> flag to <code>gbc</code> (the Bond compiler tool).</p>
<p>Note that gRPC doesnâ€™t provide a messaging pattern that matches the semantics of methods with a return type of <code>nothing</code>; to compensate, <code>gbc</code> provides generated wrappers to simulate the appropriate semantics.</p>
<p>Also note that Bond-over-gRPC only provides interfaces for gRPCâ€™s streaming in C#; this functionality will be added to C++ in the coming months.</p>
<h1 id="implementations">Implementations</h1>
<p>Bond-over-gRPC is available for C# and C++.</p>
<h2 id="bond-over-grpc-for-c">Bond-over-gRPC for C#</h2>
<p>Given a service definition like the following:</p>
<pre><code>service Example
{
    ExampleResponse ExampleMethod(ExampleRequest);
}</code></pre>
<p><code>gbc</code> will generate C# classes for gRPC with the <code>--grpc</code> flag:</p>
<pre><code>gbc c# --grpc example.bond</code></pre>
<p>The key generated C# classes for gRPC are:</p>
<ul>
<li>A simple class with the name of the service (e.g.: <code>Example</code>). This class provides some basic encapsulation of the server-side service base, the client-side proxy stub, and some static methods and data members for initialization.</li>
<li>The service base, which is named with the name of the service plus the suffix <code>Base</code> (e.g.: <code>Example.ExampleBase</code>). This class has abstract methods for each of the methods defined in the service IDL, serving as a base for the concrete implementation which will provide the actual server-side business logic.</li>
<li>The proxy stub, which is named with the name of the service plus the suffix <code>Client' (e.g.:</code>Example.ExampleClient`). This is used to invoke the service from the client side.</li>
</ul>
<p>To build the service functionality, simply write a concrete service implementation by subclassing the server base and supplying the business logic:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="kw">public</span> <span class="kw">class</span> ExampleServiceImpl : Example.<span class="fu">ExampleBase</span>
{
    <span class="kw">public</span> <span class="kw">override</span> async Task&lt;IMessage&lt;ExampleResponse&gt;&gt; <span class="fu">ExampleMethod</span>(IMessage&lt;ExampleRequest&gt; param, ServerCallContext context)
    {
        ExampleRequest request = param.<span class="fu">Payload</span>.<span class="fu">Deserialize</span>();
        <span class="dt">var</span> response = <span class="kw">new</span> <span class="fu">ExampleResponse</span>();

        <span class="co">// Service business logic goes here</span>

        <span class="kw">return</span> Message.<span class="fu">From</span>(response);
    }
}</code></pre></div>
<p>This service implementation is hooked up to a gRPC server as follows:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> server = <span class="kw">new</span> Grpc.<span class="fu">Core</span>.<span class="fu">Server</span>
{
    Services = { Example.<span class="fu">BindService</span>(<span class="kw">new</span> <span class="fu">ExampleServiceImpl</span>()) },
    Ports = { <span class="kw">new</span> Grpc.<span class="fu">Core</span>.<span class="fu">ServerPort</span>(ExampleHost, ExamplePort, Grpc.<span class="fu">Core</span>.<span class="fu">ServerCredentials</span>.<span class="fu">Insecure</span>) }
};
server.<span class="fu">Start</span>();</code></pre></div>
<p>At this point the server is ready to receive requests and route them to the service implementation.</p>
<p>On the client side, the proxy stub establishes a connection to the server like this:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> channel = <span class="kw">new</span> Grpc.<span class="fu">Core</span>.<span class="fu">Channel</span>(ExampleHost, ExamplePort, Grpc.<span class="fu">Core</span>.<span class="fu">ChannelCredentials</span>.<span class="fu">Insecure</span>);
<span class="dt">var</span> client = <span class="kw">new</span> Example.<span class="fu">ExampleClient</span>(channel);</code></pre></div>
<p>The proxy stub can then be used to make calls to the server as follows:</p>
<div class="sourceCode"><pre class="sourceCode csharp"><code class="sourceCode cs"><span class="dt">var</span> request = <span class="kw">new</span> <span class="fu">ExampleRequest</span>();
<span class="co">// Fill in request fields here</span>

IMessage&lt;ExampleResponse&gt; responseMessage = await client.<span class="fu">Method</span>(request);

ExampleResponse response = responseMessage.<span class="fu">Payload</span>.<span class="fu">Deserialize</span>().<span class="fu">Payload</span>;
<span class="co">// Examine response here</span></code></pre></div>
<p>Note that the signatures generated by <code>gbc</code> are slightly different from the ones in the gRPC documentation: on the service side, the request is wrapped in <code>IMessage&lt;T&gt;</code> and on the client side, the response is wrapped in <code>IMessage&lt;T&gt;</code>; this allows for better control over the time of deserialization and also helps prevent slicing when using polymorphic Bond types. Note also that Bond-over-gRPC does not provide synchronous APIs in C# by design.</p>
<p>For more information about gRPC in C#, take a look at the <a href="http://www.grpc.io/docs/tutorials/basic/csharp.html">gRPC C# tutorial</a>.</p>
<p>There is a <a href="https://github.com/microsoft/bond-grpc-examples">Bond-over-gRPC standalone example project</a>.</p>
<p>See also the following example:</p>
<!-- These are in thematic order, from simplier to more advanced, not in
alphabetical order. -->
<ul>
<li><code>examples/cs/grpc/pingpong</code></li>
<li><code>examples/cs/grpc/streaming</code></li>
<li><code>examples/cs/grpc/scalar</code></li>
<li><code>examples/cs/grpc/shared-types-assembly</code></li>
</ul>
<h2 id="bond-over-grpc-for-c-1">Bond-over-gRPC for C++</h2>
<p>Given a service definition like the following:</p>
<pre><code>service Example
{
    ExampleResponse ExampleMethod(ExampleRequest);
}</code></pre>
<p><code>gbc</code> will generate C++ classes for gRPC with the <code>--grpc</code> flag:</p>
<pre><code>gbc c++ --grpc example.bond</code></pre>
<p>The key generated C++ classes for gRPC are:</p>
<ul>
<li>A simple class with the name of the service (e.g.: <code>Example</code>). This class provides some basic encapsulation of the server-side service base and the client-side proxy stub.</li>
<li>The service base, which is an inner class named <code>Service</code> (e.g.: <code>Example::Service</code>). This class has abstract methods for each of the methods defined in the service IDL, serving as a base for the concrete implementation which will provide the actual server-side business logic.</li>
<li>The proxy stub, which is an inner class named <code>Client</code> (e.g.: <code>Example::Client</code>). This is used to invoke the service from the client side.</li>
</ul>
<p>To build the service functionality, simply write a concrete service implementation by subclassing the server base and supplying the business logic:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">class</span> ExampleServiceImpl <span class="kw">final</span> : <span class="kw">public</span> Example::Service
{
<span class="kw">public</span>:
    <span class="kw">using</span> Example::Service::Service;

<span class="kw">private</span>:
    <span class="dt">void</span> ExampleMethod(
        bond::ext::grpc::unary_call&lt;ExampleRequest, ExampleResponse&gt; call) <span class="kw">override</span>
    {
        ExampleRequest request = call.request().Deserialize();
        ExampleResponse response;

        <span class="co">// Service business logic goes here</span>

        call.Finish(response);
    }
}</code></pre></div>
<p>This service implementation is hooked up to a gRPC server as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">bond::ext::grpc::thread_pool threadPool;
<span class="at">const</span> <span class="bu">std::</span>string server_address{ Host + <span class="st">&quot;:&quot;</span> + Port };

<span class="bu">std::</span>unique_ptr&lt;ExampleServiceImpl&gt; service{ <span class="kw">new</span> ExampleServiceImpl{ threadPool } };

grpc::ServerBuilder builder;
builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());

<span class="kw">auto</span> server = bond::ext::grpc::server::Start(builder, <span class="bu">std::</span>move(service));</code></pre></div>
<p>At this point the server is ready to receive requests and route them to the service implementation.</p>
<p>On the client side, the proxy stub establishes a connection to the server like this:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp"><span class="kw">auto</span> ioManager = <span class="bu">std::</span>make_shared&lt;bond::ext::grpc::io_manager&gt;();
bond::ext::grpc::thread_pool threadPool;
<span class="at">const</span> <span class="bu">std::</span>string server_address{ Host + <span class="st">&quot;:&quot;</span> + Port };

Example::Client client{
    grpc::CreateChannel(server_address, grpc::InsecureChannelCredentials()),
    ioManager,
    threadPool };</code></pre></div>
<p>The proxy stub can then be used to make calls to the server as follows:</p>
<div class="sourceCode"><pre class="sourceCode cpp"><code class="sourceCode cpp">ExampleRequest request;
<span class="co">// Fill in request fields here</span>

<span class="co">// Blocking version using std::future</span>
<span class="cf">try</span>
{
    ExampleResponse response = client.AsyncExampleMethod(request)
        .get().response().Deserialize();
    <span class="co">// Examine response here</span>
}
<span class="cf">catch</span> (<span class="at">const</span> bond::ext::grpc::UnaryCallException&amp; e)
{
    <span class="co">// Examine e.status()</span>
}

<span class="co">// Async version with a callback</span>
client.AsyncExampleMethod(
    request,
    [](bond::ext::grpc::unary_call_result&lt;ExampleResponse&gt; result)
    {
        <span class="cf">if</span> (result.status().ok())
        {
            ExampleResponse response = result.response().Deserialize();
            <span class="co">// Examine response here</span>
        }
        <span class="cf">else</span>
        {
            <span class="co">// Examine result.status()</span>
        }
    });</code></pre></div>
<p>Note these APIs are significantly different from the APIs presented in the gRPC documentation; Bond-over-gRPC is attempting to provide a more straightforward API for asynchronous communication than gRPC currently presents in C++. Bond-over-gRPC does not provide synchronous APIs in C++ by design.</p>
<p>The proxy stub has a number of overloads for each method. The simplest is demonstrated above, and there are ones that take <code>bonded&lt;T&gt;</code> and <code>grpc::ClientContext</code> arguments.</p>
<p>Using <code>bonded&lt;T&gt;</code> to wrap the request and response objects allows for better control over the time of deserialization and also helps prevent slicing when using polymorphic Bond types. As demonstrated above, convenience APIs are provided in some places to hide the use <code>bonded&lt;T&gt;</code> where possible. For use of <code>bonded</code> request objects and <code>ClientContext</code> arguments, see the pingpong example.</p>
<p>For more information about gRPC in C++, take a look at the <a href="http://www.grpc.io/docs/tutorials/basic/c.html">gRPC C++ tutorial</a>; however, keep in mind that the Bond-over-gRPC APIs diverge significantly from those documented there.</p>
<p>See also the following example:</p>
<ul>
<li><code>examples/cpp/grpc/helloworld</code></li>
<li><code>examples/cpp/grpc/pingpong</code></li>
</ul>
</div>
</div>
</body>
</html>
